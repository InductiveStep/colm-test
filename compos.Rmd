---
title: "Did turnout predict the composition of Labour, Tory, and Reform votes in the 2024 UK general election?"
author: "Andi Fugard (@andi@sciences.social)"
date: 10 July 2024
output:
  html_document:
    df_print: paged
  html_notebook:
    code_folding: none
---

```{r}
#devtools::install_github("DavidFirth/compos")
library(conflicted)
library(tidyverse)
library(compos)
library(ggmice)
library(mice)
```

This is an excuse to try out the {compos} package, by David Firth and Fiona Sammut. The data used below was collated and published by [Democracy Club](https://candidates.democracyclub.org.uk/data/?election_id=parl.2024-07-04&field_group=results) under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/). I manually updated results for Edinburgh North and Leith since (on 9 July 2024) the turnout and total electorate values were mixed up (turnout percentage would have been over 100%, though was capped at 100%). This has now (10 July) been fixed in the original. The House of Commons Library is due to publish its own voting dataset [here](https://commonslibrary.parliament.uk/research-briefings/cbp-10009/) around 12 July.


## Setup the data

```{r}
ge_dat <- read_csv("uk_general_election_2024.csv")
```

Filter so we only have Labour, Tory, and Reform.

```{r}
parties <- c("Labour and Co-operative Party",
             "Labour Party",
             "Conservative and Unionist Party",
             "Reform UK")
```


And pivot wider, with all the data we want:

```{r}
simp_dat <- ge_dat |>
  dplyr::filter(party_name %in% parties) |>
  mutate(
    part = case_when(
      party_name == "Labour and Co-operative Party" ~ "Lab",
      party_name == "Labour Party" ~ "Lab",
      party_name == "Conservative and Unionist Party" ~ "Con",
      party_name == "Reform UK" ~ "Ref",     
      .default = NA_character_
    )
  ) |>
  select(post_label, part, votes_cast, turnout_percentage) |>
  pivot_wider(names_from = "part", values_from = "votes_cast")
simp_dat
```


```{r}
simp_dat |> summary()
```

```{r}
plot_pattern(simp_dat, rotate = TRUE)
```



What percentage of missing data on turnout?

```{r}
(simp_dat$turnout_percentage |> is.na() |> mean() * 100) |> round(0)
```


Zap all the rows with any missing data (e.g., Reform didn't stand a candidate or no turnout data is available).

```{r}
for_analy_counts <- na.omit(simp_dat)
```

Create another data frame with percentages, conditional on voting for one of these three parties.

```{r}
perc <- for_analy_counts |>
  pivot_longer(names_to = "Party",
               values_to = "Votes",
               cols = Ref:Con) |>
  group_by(post_label) |>
  mutate(Perc = 100 * Votes / sum(Votes))
perc
```

## Have a look

```{r dpi=300}
perc |>
  ggplot(aes(turnout_percentage, Perc, colour = Party)) +
  geom_point(size = .7) +
  geom_smooth(se = FALSE,
              method = "loess",
              formula = y ~ x) +
  labs(
    x = "Turnout (%)",
    y = "Votes (%)",
    title = "UK general election 2024",
    caption = "Percentage votes are conditional on voting Tory, Labour, or Reform"
  ) +
  scale_color_manual(values = c("#0087dc", "#d50000", "#12b6cf"))
```



## Modelling

### Fit the models using the original counts

Now, onto the modelling. These use the generalized Wedderburn logit model.

```{r}
mod1_count <- colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 1, data = for_analy_counts)
mod2_count <- colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 2, data = for_analy_counts)
mod3_count <- colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 3, data = for_analy_counts)
```


```{r}
short_sum <- function(mod) {
  (mod |> summary())$Coefficients
}
```

```{r}
mod1_count |> short_sum()
mod2_count |> short_sum()
mod3_count |> short_sum()
```

I need to RTFM to work out how to interpret the coefficients; however, the estimates/SE for turnout are over 14 for the comparisons of Labour versus Conservative and Reform versus conservative. They are around 4 for Labour versus Reform.



### Try again with percentages

If I've understood correctly, then using the percentages as outcomes, rather than counts, should give the same results:

```{r}
for_analy_percs <- perc |>
  select(-Votes) |>
  pivot_wider(names_from = "Party",
              values_from = "Perc")
for_analy_percs
```

```{r}
mod1_perc <- colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 1, data = for_analy_percs)
mod2_perc <- colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 2, data = for_analy_percs)
mod3_perc <- colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 3, data = for_analy_percs)
```

Reference level Con:

```{r}
mod1_count |> short_sum()
mod1_perc  |> short_sum()
```

Reference level Lab:

```{r}
mod2_count |> short_sum()
mod2_perc  |> short_sum()
```

Reference level Reform:

```{r}
mod3_count |> short_sum()
mod3_perc  |> short_sum()
```

And indeed they do.


## Multiple imputation -- danger danger, going beyond the function manual...

Earlier we just zapped all missing data. Let's bring back missingness in the turnouts and only drop rows where one or more of the three parties didn't have a candidate.


```{r}
names(simp_dat)
```


```{r}
counts_with_miss <- simp_dat |>
  drop_na(Ref:Con)
```


```{r}
plot_pattern(counts_with_miss, rotate = TRUE)
```


Impute 50 times with default settings.

```{r}
set.seed(1337)
imp <- mice(counts_with_miss, m = 50)
```


Fit (one of) the model(s) to each imputed dataset.

```{r}
mods <- with(imp, colm(cbind(Con, Lab, Ref) ~ turnout_percentage, ref = 1))
```


```{r}
get_params <- function(mod, comp = 1, pred) {
  the_coefs <- summary(mod)$Coefficients[[comp]]
  res <- the_coefs[pred, ]
  names(res) <- c("B", "SE")
  res
}
```


```{r}
get_params(mods$analyses[[1]], 1, "turnout_percentage")
```



```{r}
the_coefs <- map(mods$analyses, \(m) get_params(m, 1, "turnout_percentage")) |> bind_rows()
the_coefs$N <- nrow(counts_with_miss)
the_coefs
```

```{r}
pooled <- pool.scalar(the_coefs$B, the_coefs$SE^2, the_coefs$N)
res <- list(B = pooled$qbar, SE = sqrt(pooled$ubar))
res$t <- res$B / res$SE
res$df <- pooled$df[1]
res$p <- as.vector(pt(abs(res$t), df = res$df, lower.tail = FALSE) * 2)
res
```

```{r}
mod1_count |> short_sum()
```
